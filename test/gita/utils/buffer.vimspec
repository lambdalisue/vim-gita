Describe gita#utils#buffer
  Before
    Init
    let g:gita#utils#buffer#separator = '_'
  End

  Context #bufname([{name}, ...])
    It should concat non empty arguments specified with separator
      let ret = gita#utils#buffer#bufname('foo', '', 'bar', 'hoge')
      Assert Equals(ret, 'foo_bar_hoge')
    End
  End

  Context #update({buflines})
    It should update contents of the current buffer without 'modified'
      Assert Equals(getline(1, '$'), [''])
      call gita#utils#buffer#update(['foo', 'bar'])
      Assert Equals(getline(1, '$'), ['foo', 'bar'])
      Assert Equals(&l:modified, 0)
    End

    It should restore cursor position
      call gita#utils#buffer#update(['foo', 'bar'])
      call setpos('.', [0, 1, 2, 0])
      call gita#utils#buffer#update(['hoge', 'hoge', 'hoge'])
      Assert Equals(getpos('.'), [0, 1, 2, 0])
    End

    It should restore modifiable
      call gita#utils#buffer#update(['foo', 'bar'])
      Assert Equals(&l:modifiable, 1)

      setlocal nomodifiable
      call gita#utils#buffer#update(['foo', 'bar'])
      Assert Equals(&l:modifiable, 0)
    End

    It should restore readonly
      call gita#utils#buffer#update(['foo', 'bar'])
      Assert Equals(&l:readonly, 0)

      setlocal readonly
      call gita#utils#buffer#update(['foo', 'bar'])
      Assert Equals(&l:readonly, 1)
    End
  End

  Context #clear_undo_history()
    It should clear undo history
      Assert True(exists('*gita#utils#buffer#clear_undo_history'))
    End
  End

  Context #open({name}[, {config}])
    It should open a new buffer on the current buffer
      let nwin = winnr('$')
      call gita#utils#buffer#open('foo')
      Assert Equals(winnr('$'), nwin)
      Assert Equals(bufname('%'), 'foo')

      call gita#utils#buffer#open('bar')
      Assert Equals(winnr('$'), nwin)
      Assert Equals(bufname('%'), 'bar')

      call gita#utils#buffer#open('hoge')
      Assert Equals(winnr('$'), nwin)
      Assert Equals(bufname('%'), 'hoge')
    End

    It should open a new window for a new buffer when 'opener: new'
      let nwin = winnr('$')
      let conf = { 'opener': 'new' }
      call gita#utils#buffer#open('foo', conf)
      Assert Equals(winnr('$'), nwin + 1)
      Assert Equals(bufname('%'), 'foo')

      call gita#utils#buffer#open('bar', conf)
      Assert Equals(winnr('$'), nwin + 2)
      Assert Equals(bufname('%'), 'bar')

      call gita#utils#buffer#open('hoge', conf)
      Assert Equals(winnr('$'), nwin + 3)
      Assert Equals(bufname('%'), 'hoge')

      " even for same named buffer
      call gita#utils#buffer#open('foo', conf)
      Assert Equals(winnr('$'), nwin + 4)
      Assert Equals(bufname('%'), 'foo')
    End

    It should NOT open a new window for a new buffer when {group} is specified
      let nwin = winnr('$')
      let conf = { 'opener': 'new', 'group': 'test' }
      call gita#utils#buffer#open('foo', conf)
      Assert Equals(winnr('$'), nwin + 1)
      Assert Equals(bufname('%'), 'foo')

      call gita#utils#buffer#open('bar', conf)
      Assert Equals(winnr('$'), nwin + 1)
      Assert Equals(bufname('%'), 'bar')

      call gita#utils#buffer#open('hoge', conf)
      Assert Equals(winnr('$'), nwin + 1)
      Assert Equals(bufname('%'), 'hoge')

      let nwin = winnr('$')
      let conf = { 'opener': 'split', 'group': 'test2' }
      call gita#utils#buffer#open('foo', conf)
      Assert Equals(winnr('$'), nwin + 1)
      Assert Equals(bufname('%'), 'foo')

      call gita#utils#buffer#open('bar', conf)
      Assert Equals(winnr('$'), nwin + 1)
      Assert Equals(bufname('%'), 'bar')

      call gita#utils#buffer#open('hoge', conf)
      Assert Equals(winnr('$'), nwin + 1)
      Assert Equals(bufname('%'), 'hoge')
    End

    It should return a dictionary with 'bufnum'
      let ret = gita#utils#buffer#open('foo')
      Assert Equals(ret.bufnum, bufnr('%'))

      let ret = gita#utils#buffer#open('bar', { 'group': 'test' })
      Assert Equals(ret.bufnum, bufnr('%'))
    End

    It should return a dictionary with 'loaded'
      let ret = gita#utils#buffer#open('foo')
      Assert True(ret.loaded)
      let ret = gita#utils#buffer#open('foo')
      Assert False(ret.loaded)

      let ret = gita#utils#buffer#open('bar', { 'group': 'test' })
      Assert True(ret.loaded)
      let ret = gita#utils#buffer#open('bar', { 'group': 'test' })
      Assert False(ret.loaded)
    End
  End
End
