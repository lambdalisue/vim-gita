let s:is_windows = has('win16') || has('win32') || has('win64')

Describe gita#utils
  Context #import({name})
    It should return an instance of a specified vital module
      let ret = gita#import('Prelude')
      let exp = g:V.import('Prelude')
      Assert Equals(ret, exp)
    End

    It should return a same instance of a specified vital module
      let ret1 = gita#import('Prelude')
      let ret2 = gita#import('Prelude')
      let ret3 = gita#import('System.Filepath')
      Assert Equals(ret1, ret2)
      Assert Same(ret1, ret2)
      Assert NotEquals(ret1, ret3)
      Assert NotSame(ret1, ret3)
    End
  End

  Context #format_string({format}, {format_map}, {data})
    It should return an empty string if an empty {format} is given
      let ret = gita#utils#format_string('', {}, {})
      Assert Equals(ret, '')
    End

    It should return a formatted string
      let format = '%foo %bar %hoge'
      let format_map = {
            \ 'foo': 'foo_value',
            \ 'bar': 'bar_value',
            \ 'hoge': 'hoge_value',
            \}
      let data = {
            \ 'foo_value': 'Hello',
            \ 'bar_value': 'Good',
            \ 'hoge_value': 'Bye',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Hello Good Bye')
    End

    It should add <left> value of %{<left>}<key> format if <key> is not empty
      let format = '%{Very }bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': 'Good',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Very Good')
    End

    It should NOT add <left> value of %{<left>}<key> format if <key> is empty
      let format = '%{Very }bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': '',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, '')
    End

    It should add <right> value of %{|<right>}<key> format if <key> is not empty
      let format = '%{| Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': 'Good',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Good Bye')
    End

    It should NOT add <right> value of %{|<right>}<key> format if <key> is empty
      let format = '%{| Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': '',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, '')
    End

    It should add <left> and <right> value of %{<left>|<right>}<key> format if <key> is not empty
      let format = '%{Hello | Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': 'Good',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Hello Good Bye')
    End

    It should NOT add <left> and <right> value of %{<left>|<right>}<key> format if <key> is empty
      let format = '%{Hello | Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': '',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, '')
    End
  End

  Context #expand({expr})
    Before
      let bufname = g:P.join(g:repository_root, 'foo.txt')
      silent execute printf('new %s', bufname)
    End
    After
      call WipeoutAll()
    End

    It should return 'filename' of gita meta when '%' is specified and filename is specified
      call gita#meta#set('filename', 'foobar.txt', '%')
      let ret = gita#utils#expand('%')
      Assert Equals(ret, 'foobar.txt')
    End

    It should return the current buffer when '%' is specified and no filename is specified
      call gita#meta#set('filename', '', '%')
      let ret = gita#utils#expand('%')
      Assert Equals(ret, bufname)
    End

    It should treat filename-modifiers
      call gita#meta#set('filename', 'foobar.txt', '%')
      let ret = gita#utils#expand('%:r')
      Assert Equals(ret, 'foobar')

      call gita#meta#set('filename', '', '%')
      let ret = gita#utils#expand('%:r')
      Assert Equals(ret, fnamemodify(bufname, ':r'))
    End

  End

  Context #ensure_abspath({path})
    Before
      let saved_cwd = getcwd()
      let file1 = g:P.join(g:repository_root, 'foo.txt')
      let file2 = g:P.join(g:repository_root, 'hoge', 'bar.txt')
      execute printf('cd %s', g:repository_root)
      call writefile(['foo'], file1)
    End
    After
      execute printf('cd %s', saved_cwd)
      call delete(file1)
    End

    It should return {path} if {path} is already an absolute path
      let abspath = g:P.join(g:repository_root, 'foo.txt')
      let ret = gita#utils#ensure_abspath(abspath)
      Assert Equals(ret, abspath)
      Assert Same(ret, abspath)
    End

    It should return an absolute path of {path} which exists
      let relpath = 'foo.txt'
      let ret = gita#utils#ensure_abspath(relpath)
      Assert NotSame(ret, relpath)
      Assert NotEquals(ret, relpath)
      Assert Equals(ret, fnamemodify(relpath, ':p'))
    End

    It should return an absolute path of {path} which does not exist
      let relpath = g:P.join('hoge', 'bar.txt')
      let ret = gita#utils#ensure_abspath(relpath)
      Assert NotSame(ret, relpath)
      Assert NotEquals(ret, relpath)
      " the behavior of ':p' is not defined for non existing file
      " thus opposite approach is required
      Assert Equals(fnamemodify(ret, ':~:.'), relpath)
    End
  End

  Context #ensure_relpath({path})
    Before
      let saved_cwd = getcwd()
      let file1 = g:P.join(g:repository_root, 'foo.txt')
      execute printf('cd %s', g:repository_root)
    End
    After
      execute printf('cd %s', saved_cwd)
    End

    It should return {path} if {path} is already a relative path
      let relpath = 'foo.txt'
      let ret = gita#utils#ensure_relpath(relpath)
      Assert Equals(ret, relpath)
      Assert Same(ret, relpath)
    End

    It should return a relative path of {path}
      let abspath = file1
      let ret = gita#utils#ensure_relpath(abspath)
      Assert NotSame(ret, abspath)
      Assert NotEquals(ret, abspath)
      Assert Equals(ret, fnamemodify(abspath, ':~:.'))
    End
  End

  Context #ensure_pathlist({pathlist})
    Before
      let bufname = g:P.join(g:repository_root, 'foo.txt')
      silent execute printf('new %s', bufname)
    End
    After
      call WipeoutAll()
    End

    It should return a list of absolute path
      let pathlist = [
            \ '%',
            \ 'foo.txt',
            \ gita#utils#ensure_abspath('bar.txt'),
            \]
      let ret = gita#utils#ensure_pathlist(pathlist)
      Assert Equals(len(ret), 3)
      Assert Equals(ret[0], gita#utils#ensure_abspath(bufname))
      Assert Equals(ret[1], gita#utils#ensure_abspath('foo.txt'))
      Assert Equals(ret[2], gita#utils#ensure_abspath('bar.txt'))

    End
  End

  Context #ensure_unixpath({path))
    if !s:is_windows || !exists('&shellslash')
      It should return a same instance of {path} in non Windows OS or without +shellslash
        let path = 'C:\Foo\Bar\Hoge.txt'
        let ret = gita#utils#ensure_unixpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End
    else
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End

      It should return a same instance of {path} in Windows if shellslash is specified
        set shellslash
        let path = 'C:\Foo\Bar\Hoge.txt'
        let ret = gita#utils#ensure_unixpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End

      It should return a modified instance of {path} in Windows if noshellslash is specified
        set noshellslash
        let path = 'C:\Foo\Bar\Hoge.txt'
        let ret = gita#utils#ensure_unixpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:/Foo/Bar/Hoge.txt')
      End
    endif
  End

  Context #ensure_realpath({path))
    if !s:is_windows || !exists('&shellslash')
      It should return a same instance of {path} in non Windows OS or without +shellslash
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = gita#utils#ensure_realpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End
    else
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End

      It should return a same instance of {path} in Windows if shellslash is specified
        set shellslash
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = gita#utils#ensure_realpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End

      It should return a modified instance of {path} in Windows if noshellslash is specified
        set noshellslash
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = gita#utils#ensure_realpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:\Foo\Bar\Hoge.txt')
      End
    endif
  End

  Context #ensure_unixpathlist({pathlist})
    if !s:is_windows || !exists('&shellslash')
      It should works as same as gita#utils#ensure_pathlist in non Windows or without +shellslash
        let pathlist = [
              \ 'C:\Foo\Bar\Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_unixpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert Equals(ret, exp)
      End
    else
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End

      It should works as same as gita#utils#ensure_pathlist in Windows if shellslash is specified
        set shellslash
        let pathlist = [
              \ 'C:\Foo\Bar\Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_unixpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert Equals(ret, exp)
      End

      It should return a modified version of gita#utils#ensure_pathlist in Windows if noshellslash is specified
        set noshellslash
        let pathlist = [
              \ 'C:\Foo\Bar\Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_unixpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert NotEquals(ret, exp)
        Assert Equals(ret, map(exp, 'fnamemodify(v:val, '':g?\\?/?'')'))
      End
    endif
  End

  Context #ensure_realpathlist({pathlist})
    if !s:is_windows || !exists('&shellslash')
      It should works as same as gita#utils#ensure_pathlist in non Windows or without +shellslash
        let pathlist = [
              \ 'C:/Foo/Bar/Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_realpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert Equals(ret, exp)
      End
    else
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End

      It should works as same as gita#utils#ensure_pathlist in Windows if shellslash is specified
        set shellslash
        let pathlist = [
              \ 'C:/Foo/Bar/Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_realpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert Equals(ret, exp)
      End

      It should return a modified version of gita#utils#ensure_pathlist in Windows if noshellslash is specified
        set noshellslash
        let pathlist = [
              \ 'C:/Foo/Bar/Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_realpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert NotEquals(ret, exp)
        Assert Equals(ret, map(exp, 'fnamemodify(v:val, '':g?/?\\?'')'))
      End
    endif
  End

End
